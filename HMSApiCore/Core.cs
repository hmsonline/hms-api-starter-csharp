using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Security.Cryptography;
using System.Net;
using System.Net.Http;
using System.IO;
using System.Diagnostics;

namespace com.healthmarketscience.api.samples.dotnet
{
    public class Core
    {
        public class HmsApiConfig
        {
            // This should be your production settings in the long run - when in trial mode you can use trial settings
            public string BasePath = "https://trial.hmsonline.com";
            public string WebserviceName = "v1";
            public string IndexName = "masterfile";

            public HmsApiConfig()
            {
            }
            public HmsApiConfig(string basePath, string webserviceName, string indexName)
            {
                this.BasePath = basePath;
                this.WebserviceName = webserviceName;
                this.IndexName = indexName;
            }
        }

        internal static HmsApiConfig ApiConfiguration = new HmsApiConfig();
        // TODO: Change these to your production values
        internal const string DEFAULT_KEY = "myKey";
        internal const string DEFAULT_SECRET = "mysecret";

        internal static Encoding DEFAULT_ENCODING = Encoding.UTF8;

        public static void SetConfiguration(HmsApiConfig config)
        {
            ApiConfiguration = config;
        }

        public static void EnableSecurityProtocol(SecurityProtocolType type = SecurityProtocolType.Tls
					        | SecurityProtocolType.Tls11
					        | SecurityProtocolType.Tls12
					        | SecurityProtocolType.Ssl3) {

    		ServicePointManager.SecurityProtocol |= type;
        }
        
        #region UrlBuilders
        internal static string HMS_API_SEARCH_WEBSERVICE_PATH()
        {
            return string.Join("/", new string[] { GetUrlBase(), "search", ApiConfiguration.IndexName });
        }
        private static string GetUrlBase()
        {
            return "/" + ApiConfiguration.WebserviceName;
        }
        #endregion

        #region Security Methods
        internal static string GenerateSignature(string contentToSign, string secretKey = DEFAULT_SECRET)
        {
            DebuggerPrint("Generating signature for: " + contentToSign + ", using secret of " + secretKey);
            byte[] key = Convert.FromBase64String(secretKey);
            byte[] content = DEFAULT_ENCODING.GetBytes(contentToSign);
            HMACSHA1 hmac = new HMACSHA1(key);
            return Convert.ToBase64String(hmac.ComputeHash(content));
        }
        internal static IDictionary<string, string> SecurityParameters
        {
            get
            {
                return new Dictionary<string, string>() {
                    { "timestamp", ((long)DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalMilliseconds).ToString() },
                    { "key", DEFAULT_KEY }
                };
            }
        }
        #endregion

        #region Webservice Call Helpers
        internal static string CallWebServicePost(string url, string postData, string secret = null, string signature = null)
        {
            return CallWebService(url, "POST", secret, signature, postData);
        }
        /// <summary>
        ///     Method that actually calls the HMS API webservice
        ///     Important things are to generate the signature based on the URL to be called and then append it as a parameter to the url
        ///     The signature needs to be generated on the url context which does NOT include the server:port and does NOT include the signature parameter itself
        ///     
        ///     NOTE: the timestamp is a parameter that's part of the url context and is related to the signature, therefore both the timestamp and the signature
        ///     should be generated just prior to the web services call itself
        /// </summary>
        /// <param name="url">URL to be accessed, e.g. /v1/search/masterfile</param>
        /// <param name="restMethod">GET, PUT, POST</param>
        /// <param name="secret">leave blank to use the default one from the Core class</param>
        /// <param name="signature">leave blank to have this autogenerated</param>
        /// <param name="postData">only relevant for POST method calls</param>
        /// <returns></returns>
        internal static string CallWebService(string url, string restMethod = "GET", string secret = null, string signature = null, string postData = null)
        {
            if (signature == null)
            {
                // generate default signature - url needs to be without the signature and without the server/host
                signature = GenerateSignature(url, secret);
            }
            if (secret == null)
            {
                secret = DEFAULT_SECRET;
            }

            url = ApiConfiguration.BasePath + url + "&signature=" + signature;

            HttpWebRequest request = WebRequest.Create(url) as HttpWebRequest;
            request.Method = restMethod;
            if (request.Method.Equals("POST") && postData != null)
            {
                // need to send the post data as json
                request.ContentType = "application/json";
                byte[] postBytes = Encoding.ASCII.GetBytes(postData);
                using (Stream postStream = request.GetRequestStream())
                {
                    postStream.Write(postBytes, 0, postData.Length);
                    postStream.Close();
                }
            }

            string responseAsString = null;
            try
            {
                HttpWebResponse response = request.GetResponse() as HttpWebResponse;
                if (response.StatusCode == HttpStatusCode.OK)
                {
                    responseAsString = string.Empty;
                    using (Stream responseStream = response.GetResponseStream())
                    {
                        using (StreamReader responseReader = new StreamReader(responseStream, DEFAULT_ENCODING))
                        {
                            responseAsString = responseReader.ReadToEnd();
                        }
                    }
                    DebuggerPrint("Successfully called URL: " + url);
                    return responseAsString;
                }
                else
                {
                    //TODO: handle error in the way you want
                    DebuggerPrint("Response Code: " + response.StatusCode + "for URL: " + url);
                }
            }
            catch (WebException we)
            {
                DebuggerPrint("Call failed to url: " + url + System.Environment.NewLine +
                    "Exception: " + we.Message);
            }
            return responseAsString;
        }
        #endregion

        #region Centralized Utility Methods
        // these methods are here just for centralization so clients can easily change it across the starter project
        internal static void DebuggerPrintWebResponse(string url, string response)
        {
            DebuggerPrint("Called: " + url + System.Environment.NewLine +
                "Return response: " + response);
        }
        internal static void DebuggerPrint(string message)
        {
            Debug.Print(message);
        }
        #endregion
    }
}
